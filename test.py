# -*- coding: utf-8 -*-
"""Test.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1roNK4clnOQnX1j5FSo4s71trGy7-sYYU

Todo el Proyecto se ejecutara en mi repositorio de drive
"""

from os import listdir, mkdir
import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from tqdm import tqdm

import skimage
from skimage.measure import label,regionprops
from skimage.segmentation import clear_border
import matplotlib.pyplot as plt
from matplotlib import colors
from matplotlib import cm
import cv2
#Interaction user
#from ipywidgets import interact, interactive, fixed, interact_manual
#import ipywidgets as widgets

#from IPython.display import HTML
#from IPython.display import clear_output
import warnings
import os
import sys
import json
import numpy as np
import time
from PIL import Image, ImageDraw
import skimage.draw
import random

from skimage import exposure
import cv2
import imageio
import numpy as np
import math
import PIL
import glob
from PIL import Image
from skimage import io
from skimage import color
from skimage import exposure
from skimage import restoration
from skimage import util
import matplotlib.pyplot as plt
from scipy.signal import convolve2d
import sys
from scipy import misc
import json
import numpy as np
from skimage import exposure
import matplotlib.pyplot as plt
import imageio
import numpy as np
import math
import PIL
import glob
from PIL import Image
from skimage import io
from skimage import color
from skimage import exposure
from skimage import restoration
from skimage import util
import matplotlib.pyplot as plt
from scipy.signal import convolve2d
import sys
from scipy import misc
import json

import cv2
import skimage
import matplotlib.pyplot as plt
import os.path
from os import path
import natsort
import load_data as data
import SimpleITK as sitk
import os


warnings.simplefilter("ignore")
warnings.filterwarnings("ignore", category=DeprecationWarning)
warnings.filterwarnings("ignore", category=UserWarning)
warnings.filterwarnings("ignore", category=FutureWarning)

ROOT_DIR = './'
assert os.path.exists(ROOT_DIR), 'ROOT_DIR does not exist'

sys.path.append(ROOT_DIR) 
from mrcnn import visualize2
from mrcnn.config import Config
from mrcnn import model as modellib, utils

from skimage import measure
from scipy import ndimage as ndi
from skimage.morphology import disk,erosion, dilation, opening, closing,area_opening
from skimage import draw
MODEL_DIR = os.path.join(ROOT_DIR, "logs")


class LugConfig(Config):
    NAME = 'lug segmentation'
    GPU_COUNT = 1
    IMAGES_PER_GPU = 1
    NUM_CLASSES = 3  # background + 1 (lug)
    IMAGE_MIN_DIM = 512
    IMAGE_MAX_DIM = 512
    RPN_ANCHOR_SCALES = (32, 64, 128, 256, 512)
    TRAIN_ROIS_PER_IMAGE = 200
    MAX_GT_INSTANCES = 5
    STEPS_PER_EPOCH = 1000
    VALIDATION_STEPS = 50
    BACKBONE = 'resnet18'

    POST_NMS_ROIS_INFERENCE = 1000 
    POST_NMS_ROIS_TRAINING = 2000

    DETECTION_MAX_INSTANCES = 100
    DETECTION_MIN_CONFIDENCE = 0.7
    DETECTION_NMS_THRESHOLD = 0.3
    
config = LugConfig()
config.display()

class InferenceConfig(LugConfig):
    GPU_COUNT = 1
    IMAGES_PER_GPU = 1
    #IMAGE_MIN_DIM = 512
    #IMAGE_MAX_DIM = 512
    DETECTION_MIN_CONFIDENCE = 0.95
    
inference_config = InferenceConfig()

model = modellib.MaskRCNN(mode="inference", config=inference_config,  model_dir=MODEL_DIR)
model_path = model.find_last()
assert model_path != "", "Provide path to trained weights"
print("Loading weights from ", model_path)
#model_path = 'logs/lug20210717T1458/mask_rcnn_lug_0100.h5'
model.load_weights(model_path, by_name=True)

def dice(im1, im2, empty_score=1.0):
    """
    Computes the Dice coefficient, a measure of set similarity.
    Parameters
    ----------
    im1 : array-like, bool
        Any array of arbitrary size. If not boolean, will be converted.
    im2 : array-like, bool
        Any other array of identical size. If not boolean, will be converted.
    Returns
    -------
    dice : float
        Dice coefficient as a float on range [0,1].
        Maximum similarity = 1
        No similarity = 0
        Both are empty (sum eq to zero) = empty_score
        
    Notes
    -----
    The order of inputs for `dice` is irrelevant. The result will be
    identical if `im1` and `im2` are switched.
    """
    im1 = np.asarray(im1).astype(np.bool)
    im2 = np.asarray(im2).astype(np.bool)

    if im1.shape != im2.shape:
        raise ValueError("Shape mismatch: im1 and im2 must have the same shape.")

    im_sum = im1.sum() + im2.sum()
    if im_sum == 0:
        return empty_score

    # Compute Dice coefficient
    intersection = np.logical_and(im1, im2)

    return 2. * intersection.sum() / im_sum


def dice_similarity(list1, list2):
  s1 = set(list1)
  s2 = set(list2)
  return float((2*len(s1.intersection(s2))) / ((len(s1) + len(s2))))
def single_jaccard_coef2(y_true, y_pred_bin):
  y_true_f = set(y_true)
  y_pred_f = set(y_pred_bin)
  return float(len(y_true_f.intersection(y_pred_f)) / len(y_true_f.union(y_pred_f)))
list1 =[]
list2 = []
class_names = [
     'BG', 'Izquierda','Derecha'
]

def clahe(image):
    img_clahe = exposure.equalize_adapthist(image, kernel_size=None, clip_limit=0.01, nbins=256)
    return img_clahe

path_images='dataset/TEST/IMAGE/'
path_masks='dataset/TEST/MASK/'




def posprocesamiento(mask):
    contours = measure.find_contours(mask)
    test_disk = np.zeros((512, 512), dtype=np.float32)
    L_disk = np.zeros((512, 512), dtype=np.float32)
    R_disk = np.zeros((512, 512), dtype=np.float32)
    if len(contours) >=2:
      for con in contours[0]: 
        rr, cc = draw.disk(con, 1)
        L_disk[rr, cc] = 1
      for con in contours[1]: 
        rr, cc = draw.disk(con, 1)
        R_disk[rr, cc] = 1
    R_disk=ndi.binary_fill_holes(R_disk)
    
    L_disk=ndi.binary_fill_holes(L_disk)
    

    test_disk=R_disk+L_disk

    test_disk = np.int32(test_disk)
    return test_disk
def create_directory(path_):
    if path.exists(path_) == False:
        os.mkdir(path_)
resultados = []
for filename in os.listdir(path_images):
    path_1 = path_images + "/" + filename
    path_2 = path_masks + "/" + filename
    cts,masks,=data.read_image_mask(path_1,path_2)
    contador = 0
    dice_metric = []
    jaccar_metric =[]
    list1 = []
    list2 = []
    for ct,mask in zip(cts,masks):
        mask = cv2.threshold(mask, 0.2, 1, cv2.THRESH_BINARY)[1]
        
        path_resultado= 'dataset/RESULT/'+ filename.split(".")[0]+"/"+str(contador)+'.png'
        path_resultado2= 'dataset/RESULT2/'+ filename.split(".")[0]+"/"+ str(contador)+'.png'
        path_resultadocolor= 'dataset/RESULTCOLOR/'+ filename.split(".")[0]+"/"+ str(contador)+'.png'
        create_directory('dataset/RESULT/'+ filename.split(".")[0])
        create_directory('dataset/RESULT2/'+ filename.split(".")[0])
        create_directory('dataset/RESULTCOLOR/'+ filename.split(".")[0])
        image = ct #clahe(ct)
        image = cv2.normalize(image , None , 0, 255, norm_type=cv2.NORM_MINMAX)
        image_array = np.zeros((512, 512,3), dtype=np.float32)
        image_array[:,:,0] = image
        image_array[:,:,1] = image
        image_array[:,:,2] = image
        results = model.detect([image_array], verbose=1)
        r = results[0]
        #image_array = cv2.normalize(image_array, None , 0, 255, norm_type=cv2.NORM_MINMAX)

        #image, image_meta, gt_class_id, gt_bbox, gt_mask =model.load_image_gt(dataset, config, image_id, use_mini_mask=False)
        masked_image_x,masked_image_y =visualize2.display_instances(image_array, r['rois'], r['masks'], r['class_ids'], class_names, r['scores'], figsize=(5,5))
        
        skimage.io.imsave(path_resultado,np.float32(masked_image_y))
        skimage.io.imsave(path_resultado2,np.float32(mask))
        skimage.io.imsave(path_resultadocolor,np.float32(masked_image_x))
        
        y_pred = masked_image_y[:,:,0] #posprocesamiento(masked_image_y[:,:,0])
        #dice_metric.append(round(dice(mask,y_pred),4))
        y_pred= cv2.threshold(y_pred, 0.2, 1, cv2.THRESH_BINARY)[1]

        y_manual = mask.flatten()
        y_test   = y_pred.flatten()
        data_manual_pro = []
        for x in range(len(y_manual)):
            if y_manual[x] == 0:
                data_manual_pro.append(0)
            else:
                data_manual_pro.append(x)
            
        data_test_pro = []
        for x in range(len(y_test)):
            if y_test[x] == 0:
                data_test_pro.append(0)
            else:
                data_test_pro.append(x)

        dice_metric.append(dice_similarity(data_manual_pro, data_test_pro))
        jaccar_metric.append(single_jaccard_coef2(data_manual_pro, data_test_pro))
    
        contador = contador + 1
    
    info ={}
    info['File'] = filename
    info['Dice'] = np.mean(dice_metric)
    info['Jaccar'] = np.mean(jaccar_metric)
    resultados.append(info)

print(resultados)
