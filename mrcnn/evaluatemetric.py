# -*- coding: utf-8 -*-
"""EvaluateMetric.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ikm2RRcqJUD5arj8kDJ_l76FUvtWc_0x

Todo el Proyecto se ejecutara en mi repositorio de drive
"""

from os import listdir, mkdir
import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from tqdm import tqdm

import skimage
from skimage.measure import label,regionprops
from skimage.segmentation import clear_border
import matplotlib.pyplot as plt
from matplotlib import colors
from matplotlib import cm
import cv2
#Interaction user
#from ipywidgets import interact, interactive, fixed, interact_manual
#import ipywidgets as widgets

#from IPython.display import HTML
#from IPython.display import clear_output
import warnings
warnings.simplefilter("ignore")
warnings.filterwarnings("ignore", category=DeprecationWarning)
warnings.filterwarnings("ignore", category=UserWarning)
warnings.filterwarnings("ignore", category=FutureWarning)

"""Evaluate metric Dice and Jaccard"""

def dice_coef_metric(probabilities: np.ndarray,
                     truth: np.ndarray,
                     treshold: float = 0.5,
                     eps: float = 1e-9) -> np.ndarray:
    """
    Calculate Dice score for data batch.
    Params:
        probobilities: model outputs after activation function.
        truth: truth values.
        threshold: threshold for probabilities.
        eps: additive to refine the estimate.
        Returns: dice score aka f1.
    """
    scores = []
    num = probabilities.shape[0]
    predictions = (probabilities >= treshold)
    assert(predictions.shape == truth.shape)
    
    #recorremos el nro de cortes
    for i in range(num):
        prediction = predictions[i]
        truth_ = truth[i]
        intersection = 2.0 * (truth_ * prediction).sum()
        union = truth_.sum() + prediction.sum()
        if truth_.sum() == 0 and prediction.sum() == 0:
            #print(1.0)
            scores.append(1.0)
        else:
            #print((intersection + eps) / union)
            scores.append((intersection + eps) / union)
    return np.mean(scores)


def jaccard_coef_metric(probabilities: np.ndarray,
               truth: np.ndarray,
               treshold: float = 0.5,
               eps: float = 1e-9) -> np.ndarray:
    """
    Calculate Jaccard index for data batch.
    Params:
        probobilities: model outputs after activation function.
        truth: truth values.
        threshold: threshold for probabilities.
        eps: additive to refine the estimate.
        Returns: jaccard score aka iou."
    """
    scores = []
    num = probabilities.shape[0]
    predictions = (probabilities >= treshold)
    assert(predictions.shape == truth.shape)
    
    #recorremos nro de cortes
    for i in range(num):
        prediction = predictions[i]
        truth_ = truth[i]
        intersection = (prediction * truth_).sum()
        union = (prediction.sum() + truth_.sum()) - intersection + eps
        if truth_.sum() == 0 and prediction.sum() == 0:
            #print(1.0)
            scores.append(1.0)
        else:
            #print((intersection + eps) / union)
            scores.append((intersection + eps) / union)
    return np.mean(scores)

import cv2
import skimage
import skimage.io
import natsort
from matplotlib.image import imread
import os.path
from os import path
kernel1 = np.ones((5,5),np.uint8)
kernel2 = np.ones((2,2),np.uint8)
pathImage = 'dataset/RESULT'
for b in os.listdir(pathImage):
  basepathAqp = "dataset/MASK/"+b
  listPath= listdir(basepathAqp)
  listPath = natsort.natsorted(listPath)
  i=0
  manualSegmarray = np.zeros((len(listPath),512,512),dtype=int)
  for a in listPath:
      img = imread(basepathAqp+"/"+a)
      data = np.asarray( img, dtype="int32" )
      manualSegmarray[i,:,:] = data
      i=i+1

  basepathAqp = "dataset/RESULT/"+b
  listPath= listdir(basepathAqp)
  listPath = natsort.natsorted(listPath)
  i=0
  automaticSegmarray = np.zeros((len(listPath),512,512))
  for a in listPath:
      #img = skimage.io.imread(basepathAqp+"/"+a)
      img = imread(basepathAqp+"/"+a)
      img = cv2.morphologyEx(img, cv2.MORPH_CLOSE, kernel1)
      img = cv2.dilate(img,kernel2,iterations = 2)
      data = np.asarray( img, dtype="int32" )
      #print(img.shape)
      automaticSegmarray[i,:,:] = data[:,:,0]
      i=1+i
  print("               ")
  print("Directory : "+ b)
  print("               ")
  print("Dice Coeff: {}".format(round(dice_coef_metric(manualSegmarray,automaticSegmarray),4)))
  print("Jaccar Coeff: {}".format(round(jaccard_coef_metric(manualSegmarray,automaticSegmarray),4)))